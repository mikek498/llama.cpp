---
description:
globs:
alwaysApply: false
---
**Rule Set 1: Problem Ingestion & Environment Analysis**

*   **Goal:** Thoroughly understand the user's reported issue, gather all necessary environmental and build context, especially concerning Python orchestration scripts and specific configurations.
*   **1.1. Detailed Problem Scoping:**
    *   *Instruction:* Elicit a precise description of the problem: compilation/link error (exact message), runtime crash (segfault, abort, with backtrace if available), incorrect behavior (NaNs, unexpected output, with specific inputs), performance bottleneck (quantified if possible), or build script failure. Identify all relevant software components, models, and quantization types (e.g., TL1, i2_s).
    *   *Method:* Ask clarifying questions. Request exact error messages, logs, and reproduction steps.
*   **1.2. Characterize Target Environment & Toolchain:**
    *   *Instruction:* Determine target architecture (ARM64/Apple Silicon), OS version, and the intended compiler toolchain (Apple Clang vs. Homebrew LLVM/Clang, specific versions). Verify environment variables (`CC`, `CXX`) and compiler paths.
    *   *Method:* Use `run_terminal_cmd` for `uname -a`, `sw_vers`, `env | grep CXX`, `which clang`, `clang --version`. Cross-reference with build script settings.
    *   *Instruction:* Specifically check compiler paths in CMake (`CMakeLists.txt`, CMakeCache.txt) and other build scripts. For Homebrew LLVM, ensure correct prefix usage (`$(brew --prefix llvm)/bin/clang`).
    *   *Method:* Use `read_file` and `grep_search` within build system files.
*   **1.3. Analyze Build System & Python Orchestration Scripts:**
    *   *Instruction:* Inspect the primary build system (CMake, Make) for architecture-specific flags (`-march=armv8-a`, `-mfpu=neon`, `-mcpu=apple-m1`), optimization levels (`-O0`, `-O2`, `-O3`), Metal flags (`-framework Metal`), and any custom compilation definitions or quantization-specific flags (e.g., `DBITNET_ARM_TL1`).
    *   *Method:* Use `read_file` for `CMakeLists.txt`, `Makefile`. Use `grep_search` for flags and definitions.
    *   *Instruction:* If Python scripts like `setup_env.py` orchestrate builds: Analyze their argument parsing, logic for determining model paths, quantization types, and how they invoke compiler/build commands. Check for verbose/debug options.
    *   *Method:* Use `read_file` to understand the Python script. Suggest running it with `-v` or `--verbose` if available, or temporarily add `print()` statements for debugging its flow.
*   **1.4. Gather and Analyze Relevant Artifacts:**
    *   *Instruction:* Collect all relevant source files (`.c`, `.cpp`, `.h`, `.m`, `.metal`), assembly files (`.S`), build scripts, and log files (`compile.log`, `quantize.log`, `cmake_output.log`).
    *   *Method:* Use `file_search` and `read_file`.
    *   *Instruction:* Attempt to reproduce the issue with a clean build (`make clean` or `rm -rf build/`) and the exact command sequence, whether provided by the user or derived from analyzing `setup_env.py`.
    *   *Method:* Use `run_terminal_cmd` for clean and build operations. Capture and analyze all output.
